import{relations as F,eq as o,count as N,sql as q,and as p,or as k,like as S,avg as v,inArray as M,gt as D,desc as U,isNotNull as E}from"drizzle-orm";import{mysqlTable as R,varchar as y,timestamp as _,tinyint as L,text as $,mysqlEnum as H,primaryKey as C}from"drizzle-orm/mysql-core";import j,{decodeJwt as O}from"@clerk/clerk-sdk-node";import{initTRPC as z,TRPCError as K}from"@trpc/server";import W from"cookies";import G from"superjson";import{connect as J}from"@planetscale/database";import{drizzle as Z}from"drizzle-orm/planetscale-serverless";import{createSelectSchema as P}from"drizzle-zod";import{z as i}from"zod";import{createHTTPHandler as Y}from"@trpc/server/adapters/standalone";import{fromNodeMiddleware as Q}from"h3";import"node:async_hooks";import V from"dotenv";const d=R("profile",{userId:y("user_id",{length:256}).notNull().primaryKey(),name:y("name",{length:50}).notNull(),handle:y("handle",{length:20}).notNull().unique(),imageUrl:y("image_url",{length:256}),bio:y("bio",{length:200}),createdAt:_("created_at").defaultNow().notNull(),updatedAt:_("updated_at").defaultNow().onUpdateNow().notNull()}),X=F(d,({many:e})=>({ratings:e(r),followers:e(l)})),r=R("ratings",{resourceId:y("resource_id",{length:256}).notNull(),userId:y("user_id",{length:256}).notNull(),rating:L("rating").notNull(),content:$("content"),category:H("category",["ALBUM","SONG","ARTIST"]).notNull(),createdAt:_("created_at").defaultNow().notNull(),updatedAt:_("updated_at").defaultNow().onUpdateNow().notNull()},e=>({pk_ratings:C({columns:[e.resourceId,e.userId]})})),l=R("followers",{userId:y("user_id",{length:256}).notNull(),followingId:y("following_id",{length:256}).notNull()},e=>({pk_ratings:C({columns:[e.userId,e.followingId]})})),ee=F(l,({one:e})=>({user:e(d,{fields:[l.userId],references:[d.userId]}),following:e(d,{fields:[l.followingId],references:[d.userId]})})),te=F(r,({one:e})=>({profile:e(d,{fields:[r.userId],references:[d.userId]})})),re=Object.freeze(Object.defineProperty({__proto__:null,followers:l,profile:d,profileRelations:X,ratings:r,ratingsRelations:te,userFollowRelation:ee},Symbol.toStringTag,{value:"Module"}));console.log(process.env.DATABASE_URL);const ne=J({url:process.env.DATABASE_URL}),B=Z(ne,{schema:re}),oe=async e=>{const n=new W(e.req,e.res).get("__session");if(!n)return{db:B,userId:null};const s=O(n);return{db:B,userId:s.payload.sub}},A=z.context().create({transformer:G});A.createCallerFactory;const w=A.procedure,x=A.router,g=A.procedure.use(({ctx:e,next:t})=>{if(!e.userId)throw new K({code:"UNAUTHORIZED",message:"You must be logged in to access this resource."});return t({ctx:{...e,userId:e.userId}})}),se=["artists","artist","albums","album","songs","song","about","terms","onboard","api","list","playlist","support","contact","friends","messages","recommendations","notifications","settings","search","home"],ie=i.string().min(1,"Must be at least 1 character").max(50,"Must be less than 50 characters"),ae=/^[a-zA-Z0-9_]+$/i,le=i.string().min(1,"Must be at least 1 character").max(20,"Must be less than 20 characters").regex(ae,"Must be letters, numbers, or _").refine(e=>se.includes(e.toLowerCase())?"Handle is reserved":!0),ue=i.string().max(200,"Must be less than 200 characters"),ce=P(d,{name:ie,handle:le,bio:ue.nullable()}),T=ce.pick({name:!0,handle:!0,imageUrl:!0,bio:!0}),de=T.extend({oldHandle:i.string().optional()}),fe=x({get:w.input(i.string()).query(async({ctx:{db:e},input:t})=>await e.query.profile.findFirst({where:o(d.handle,t)})??null),me:g.query(async({ctx:{db:e,userId:t}})=>await e.query.profile.findFirst({where:o(d.userId,t)})??null),distribution:w.input(i.string()).query(async({ctx:{db:e},input:t})=>(await e.select({rating:r.rating,rating_count:N(r.rating)}).from(r).where(o(r.userId,t)).groupBy(r.rating).orderBy(r.rating)).reduce((a,{rating:u,rating_count:c})=>(a[u-1]=c,a),Array(10).fill(0))),followCount:w.input(i.object({userId:i.string(),type:i.literal("followers").or(i.literal("following"))})).query(async({ctx:{db:e},input:{userId:t,type:n}})=>{if(!!!await e.query.profile.findFirst({where:o(d.userId,t)}))throw new Error("User Doesn't Exist");let a;return n==="followers"?a=await e.select({count:q`count(*)`.mapWith(Number)}).from(l).where(o(l.followingId,t)):a=await e.select({count:q`count(*)`.mapWith(Number)}).from(l).where(o(l.userId,t)),a.length?a[0].count:0}),isFollowing:g.input(i.string()).query(async({ctx:{db:e,userId:t},input:n})=>!t||t===n?!1:!!await e.query.followers.findFirst({where:p(o(l.userId,t),o(l.followingId,n))})),followProfiles:w.input(i.object({profileId:i.string(),type:i.literal("followers").or(i.literal("following"))})).query(async({ctx:{db:e,userId:t},input:{profileId:n,type:s}})=>{const a=!!await e.query.profile.findFirst({where:o(d.userId,n)});if(console.log(`


${a}


`),!a)throw new Error("User Doesn't Exist");return s==="followers"?(await e.query.followers.findMany({where:o(l.followingId,n),with:{user:{extras:{isFollowing:q`exists(select 1 from followers where user_id = ${t} and following_id = ${l.userId})`.as("isFollowing")}}}})).map(({user:c,userId:f,followingId:m})=>({userId:f,followingId:m,profile:c})):(await e.query.followers.findMany({where:o(l.userId,n),with:{following:{extras:{isFollowing:q`exists(select 1 from followers where user_id = ${t} and following_id = ${l.userId})`.as("isFollowing")}}}})).map(({following:c,userId:f,followingId:m})=>({userId:f,followingId:m,profile:c}))}),create:g.input(T).mutation(async({ctx:{db:e,userId:t},input:n})=>{await e.insert(d).values({...n,userId:t}),await j.users.updateUser(t,{publicMetadata:{onboarded:!0}})}),update:g.input(de).mutation(async({ctx:{db:e,userId:t},input:n})=>{await e.update(d).set(n).where(o(d.userId,t))}),follow:g.input(i.string()).mutation(async({ctx:{db:e,userId:t},input:n})=>{if(t===n)throw new Error("User Cannot Follow Themselves");if((await e.select().from(l).where(p(o(l.userId,t),o(l.followingId,n)))).length>0)throw new Error("User Already Follows");await e.insert(l).values({userId:t,followingId:n})}),unFollow:g.input(i.string()).mutation(async({ctx:{db:e,userId:t},input:n})=>{if(t===n)throw new Error("User Cannot unFollow Themselves");if((await e.select().from(l).where(p(o(l.userId,t),o(l.followingId,n)))).length>0)await e.delete(l).where(p(o(l.userId,t),o(l.followingId,n)));else throw new Error("User Doesn't Follow")}),handleExists:w.input(i.string()).query(async({ctx:{db:e},input:t})=>!!await e.query.profile.findFirst({where:o(d.handle,t)})),search:w.input(i.string()).query(async({ctx:{db:e},input:t})=>await e.query.profile.findMany({where:k(S(d.handle,`%${t}%`),S(d.name,`%${t}%`))}))});i.object({resourceId:i.string(),average:i.string().nullable(),total:i.number()});const I=P(r,{rating:i.number().min(1).max(10),content:i.string().min(1).max(1e4)}),h=I.pick({resourceId:!0,category:!0}),pe=I.pick({resourceId:!0,category:!0,rating:!0}).extend({rating:I.shape.rating.nullable()}),we=I.pick({resourceId:!0,category:!0,content:!0,rating:!0});I.pick({category:!0});const b=i.object({cursor:i.number().min(1).max(100).optional(),limit:i.number().optional()}),ge=x({get:w.input(h).query(async({ctx:{db:e},input:{resourceId:t,category:n}})=>({...(await e.select({average:v(r.rating),total:N(r.rating)}).from(r).where(p(o(r.resourceId,t),o(r.category,n))))[0],resourceId:t})),list:w.input(h.array()).query(async({ctx:{db:e},input:t})=>await e.select({average:v(r.rating),total:N(r.rating),resourceId:r.resourceId}).from(r).where(M(r.resourceId,t.map(n=>n.resourceId))).groupBy(r.resourceId)),trending:w.query(async({ctx:{db:e}})=>await e.select({total:N(r.rating),resourceId:r.resourceId}).from(r).where(p(o(r.category,"ALBUM"),D(r.createdAt,new Date(Date.now()-1e3*60*60*24*7)))).groupBy(r.resourceId).orderBy(({total:t})=>U(t)).limit(20)),top:w.query(async({ctx:{db:e}})=>await e.select({average:v(r.rating),resourceId:r.resourceId}).from(r).where(o(r.category,"ALBUM")).groupBy(r.resourceId).orderBy(({average:t})=>U(t)).limit(20)),feed:x({recent:w.input(b).query(async({ctx:{db:e},input:{limit:t=20,cursor:n=0}})=>{const s=await e.query.ratings.findMany({where:E(r.content),limit:t,offset:n,orderBy:(u,{desc:c})=>[c(u.createdAt)],with:{profile:!0}});let a;return s.length>t&&(s.pop(),a=n+s.length),{items:s,nextCursor:a}}),following:g.input(b).query(async({ctx:{db:e,userId:t},input:{limit:n=20,cursor:s=0}})=>{const a=await e.query.followers.findMany({where:o(l.userId,t)});if(a.length===0)return[];const u=await e.query.ratings.findMany({where:p(M(r.userId,a.map(f=>f.followingId)),E(r.content)),limit:n+1,offset:s,orderBy:(f,{desc:m})=>[m(f.createdAt)],with:{profile:!0}});let c;return u.length>n&&(u.pop(),c=s+u.length),{items:u,nextCursor:c}}),community:w.input(b.extend({resource:h})).query(async({ctx:{db:e},input:{limit:t=20,cursor:n=0,resource:{resourceId:s,category:a}}})=>{const u=await e.query.ratings.findMany({where:p(o(r.resourceId,s),o(r.category,a),E(r.content)),limit:t+1,offset:n,orderBy:(f,{desc:m})=>[m(f.createdAt)],with:{profile:!0}});let c;return u.length>t&&(u.pop(),c=n+u.length),{items:u,nextCursor:c}})}),user:x({get:g.input(h).query(async({ctx:{db:e,userId:t},input:{resourceId:n,category:s}})=>{const a=await e.query.ratings.findFirst({where:p(o(r.resourceId,n),o(r.category,s),o(r.userId,t))});return a||null}),getList:g.input(h.array()).query(async({ctx:{db:e,userId:t},input:n})=>await e.query.ratings.findMany({where:p(M(r.resourceId,n.map(s=>s.resourceId)),o(r.userId,t))})),recent:w.input(b.extend({profileId:i.string(),rating:i.number().optional(),category:i.enum(["ALBUM","SONG"]).optional()})).query(async({ctx:{db:e},input:{limit:t=20,cursor:n=0,rating:s,category:a,profileId:u}})=>{let c;s&&a?c=p(o(r.userId,u),o(r.rating,s),o(r.category,a)):a?c=p(o(r.userId,u),o(r.category,a)):s?c=p(o(r.userId,u),o(r.rating,s)):c=o(r.userId,u);const f=await e.query.ratings.findMany({limit:t,offset:n,orderBy:U(r.updatedAt),where:c,with:{profile:!0}});let m;return f.length>t&&(f.pop(),m=n+f.length),{items:f,nextCursor:m}})}),rate:g.input(pe).mutation(async({ctx:{db:e,userId:t},input:{rating:n,resourceId:s,category:a}})=>{n===null?await e.delete(r).where(p(o(r.userId,t),o(r.resourceId,s),o(r.category,a))):await e.insert(r).values({rating:n,resourceId:s,category:a,userId:t}).onDuplicateKeyUpdate({set:{rating:n,resourceId:s,category:a,userId:t}})}),review:g.input(we).mutation(async({ctx:{db:e,userId:t},input:n})=>{await e.insert(r).values({...n,userId:t}).onDuplicateKeyUpdate({set:{...n,userId:t}})})}),me=x({ratings:ge,profiles:fe,test:w.query(async()=>"Hello World")});V.config();const ye=Y({router:me,createContext:oe}),Se=Q((e,t)=>(e.url=e.url.replace("/trpc",""),ye(e,t)));export{Se as default};
